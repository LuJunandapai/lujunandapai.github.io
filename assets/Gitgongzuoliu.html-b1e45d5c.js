import{_ as a,p as e,q as s,Y as n}from"./framework-e1bed10d.js";const i={},t=n(`<h1 id="git版本控制" tabindex="-1"><a class="header-anchor" href="#git版本控制" aria-hidden="true">#</a> Git版本控制</h1><h2 id="_1-git历史" tabindex="-1"><a class="header-anchor" href="#_1-git历史" aria-hidden="true">#</a> 1.Git历史</h2><p>同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。到 2002 年，整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。</p><p>到 2005 年的时候，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统订了若干目标：</p><p>1、速度快 2、简单的设计 3、对非线性开发模式的强力支持（允许上千个并行开发的分支） 4、完全分布式 5、有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</p><h2 id="_2-git-的安装与配置" tabindex="-1"><a class="header-anchor" href="#_2-git-的安装与配置" aria-hidden="true">#</a> 2. Git 的安装与配置</h2><h3 id="_2-1-安装" tabindex="-1"><a class="header-anchor" href="#_2-1-安装" aria-hidden="true">#</a> 2.1 安装</h3><p>官网下载](https://git-scm.com/downloads)</p><h3 id="_2-2-配置" tabindex="-1"><a class="header-anchor" href="#_2-2-配置" aria-hidden="true">#</a> 2.2 配置</h3><p>1、当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中。如下全局设置</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">&quot;&lt;用户名&gt;&quot;</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">&quot;&lt;邮箱&gt;&quot;</span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> push.default simple  
<span class="token function">git</span> config <span class="token parameter variable">--global</span> core.editor notepad   <span class="token comment">#如果你想使用一个不同的文本编辑器</span>

<span class="token function">git</span> config <span class="token parameter variable">-l</span> <span class="token comment">###查看全局配置</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些信息写到全局配置文件通常在【C:\\Users\\Administrator.gitconfig】，Administrator不同电脑可能有所区别，重申一遍，你只需要做一次这个设置。如果你传递了 --global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要--global选项</p><blockquote><p>push.default simple：Git 2.x 默认的是 simple，意味着执行 git push 没有指定分支时，只有当前分支会被 push 到你使用 git pull 获取的代码</p><p>push.default matching： Git 1.x 的默认行为，其意是如果你执行 git push 但没有指定分支，它将 push 所有你本地的分支到远程仓库中对应匹配的分支</p></blockquote><p>2、在使用 git 之前创建 SSH Key，未来会使用到：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-b</span> <span class="token number">4096</span> <span class="token parameter variable">-C</span> <span class="token string">&quot;备注&quot;</span>

一路回车

<span class="token function">cat</span> ~/.ssh/id_rsa.pub
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>默认在C:\\Users\\Administrator\\.ssh目录下生成密钥对</p><h2 id="_3-gitkraken" tabindex="-1"><a class="header-anchor" href="#_3-gitkraken" aria-hidden="true">#</a> 3. GitKraken</h2><h3 id="_3-1-安装与破解" tabindex="-1"><a class="header-anchor" href="#_3-1-安装与破解" aria-hidden="true">#</a> 3.1 安装与破解</h3><p>GitKraken 是 Git 客户端界的后起之秀，它的出现打破了『SourceTree 最好用』的说法。不少 SourceTree 的用户从 SourceTree 上迁移到了 GitKraken 。GitKranken 的特点在于，界面更简洁、友好，这样在保证功能不少的情况下，上手比 SourceTree 更快。</p><p>GitKranken 比 SourceTree 还有一个有优势之处：它跨平台，在 Linux 上可用。</p><p>不过，GitKraken 从 <strong>6.5.3</strong> 版本开始收费，它的最后一个免费版本是 <strong>6.5.1</strong> ，当你使用收费版本而又未付费时，使用 GitKranken 将无法打开本地仓库，这就约等于无法使用了。</p><p>对于这个问题解决的办法自然就是破解：<strong>使用一个可免费试用的低版本，并且关闭它的自动升级功能</strong></p><p>下载（或向老师要）6.5.1 的 GitKraken 安装程序</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>https://release.axocdn.com/linux/GitKraken-v6.5.1.deb
https://release.axocdn.com/linux/GitKraken-v6.5.1.rpm
https://release.axocdn.com/linux/GitKraken-v6.5.1.tar.gz
https://release.axocdn.com/win64/GitKrakenSetup-6.5.1.exe
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>安装过程一路 Next，没有特殊之处。</p><p>注意</p><blockquote><p>安装程序 GitKrakenSetup-6.5.1.exe 只用执行一次，别傻了吧唧地反复点击、运行它。导致，后面 “update.exe 怎么删不掉？” 情况地出现！</p></blockquote><h3 id="_3-2-破解" tabindex="-1"><a class="header-anchor" href="#_3-2-破解" aria-hidden="true">#</a> 3.2. 破解</h3><p>理论上，安装 GitKraken 6.5.1 版之后直接使用就可以，但是，讨厌的是 GitKraken 会『<strong>自动升级</strong>』。一旦自动升级，你的 GitKraken 自然就不再是最后一个免费版 6.5.1 了。</p><p>GitKraken “做手脚” 的地方就在于：<strong>正常安装之后，你桌面生成的 GitKraken 的快捷方式链接到的是 GitKranken 安装程序的 <code>update.exe</code></strong>！所以，你通过点击快捷方式运行GitKraken 时，它总会先检查服务器上是否有新版本可以升级！如果有，GitKraken 就会下载最新本版，自我更新。</p><p>所以，破解的关键在于：<strong>干掉 update.exe ，让 GitKraken 无法升级，定死再 6.5.1 版本</strong></p><p>在安装 GitKraken 之后，在你的安装目录（C:\\Users\\Administrator\\AppData\\Local\\gitkraken）下会有一个名为 Update.exe的可执行程序</p><p>1、这个文件就是 GitKraken 运行期间『悄悄』访问的服务器的进程。将它删除（或逻辑上删除，例如改名为 <em>Update.exe.bak</em> 这种无法启动的文件名），这样 GitKraken 也无法获取最新的版本信息，进而无法自我更新</p><p>处理完 update.exe 的问题之后，在 update.exe 的同级的 app-6.5.1 目录下找到 gitkraken.exe，通过它来启动 GitKraken <img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211228152948920.png" alt="image-20211228152948920"></p><p>2、然后右键桌面gitkraken.exe的快捷方式图标，将目标改为：</p><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211228153122224.png" alt="image-20211228153122224"></p><p>3、打开windows的注册表， 在：计算机\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell下面找到 GitKraken ，删除这个目录</p><h2 id="_4-git基础" tabindex="-1"><a class="header-anchor" href="#_4-git基础" aria-hidden="true">#</a> 4.git基础</h2><h3 id="_4-1-什么是版本控制系统" tabindex="-1"><a class="header-anchor" href="#_4-1-什么是版本控制系统" aria-hidden="true">#</a> 4.1. 什么是版本控制系统</h3><p>版本控制系统（VCS）是将『<strong>什么时候、谁、对什么文件做了怎样的修改</strong>』这样的信息以版本的形式保存并进行管理的系统，简单来说，版本控制系统会去记录它所管理的文件的『<strong>历史版本</strong>』</p><p>版本控制系统 “不是网盘，而胜似网盘” ：</p><ul><li>它和网盘的相同点在于：它可以位于局域网，或者是外网上的一台服务器上，你和你的小伙伴们可以在不同的地方、不同的电脑上，以它为 “中介、桥梁” 共享文件。</li><li>它胜似网盘的地方在于：它能记录你和你的小伙伴们对文件修改的所有历史版本，并且你可以将你的文件恢复到你感兴趣的某个历史版本。</li></ul><p>Git 并非唯一的版本控制系统，它的前辈是 Subversion 。2014 年 Git 的市场占有率首次超过 Subversion ，成为主流。</p><p>Git 相较于 SVN的先进之处在于：</p><p>1、Subversion 中的版本信息仅存在于中央仓库，而 Git 中所有的本地库中都有完整的历史版本信息。</p><p>2、Subversion 中的 “分支” 很重，创建分支、删除分支、合并分支等分支相关操作很慢，而 Git 中的分支很轻，分支操作是 Git 的拳头特性</p><h3 id="_4-2-创建本地仓库" tabindex="-1"><a class="header-anchor" href="#_4-2-创建本地仓库" aria-hidden="true">#</a> 4.2 创建本地仓库</h3><p>Git 可以管理任何一个文件夹（及其中内容），只要在该文件夹中执行 <strong>git init</strong>，那么就在该文件夹下创建一个名字为 .git的子文件夹，这个子文件夹就是本地仓库，它里面会存放被 Git 所管理的文件的相关信息（例如，历史版本），而该目录就是我们说的工作目录，我们可以把我们的项目放到这个工作目录中</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">git</span> init
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>警告</p><p>你不要自己去操作 <strong>.git</strong> 目录，更不要随意将 <strong>.git</strong> 目录删除。这个目录下的内容是 Git 来使用和操作的</p></blockquote><p>当你执行完 git init 命令之后，当前目录就位于 Git 的监管范畴内，这个目录中的文件的变动（新创建的、被删除的、内容有更新的）都会被 Git 察觉。</p><p>在 Gitkraken 中打开这个刚刚初始化的 Git 仓库效果如下：</p><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211228154653515.png" alt="image-20211228154653515"></p><h3 id="_4-3-git基本流程操作" tabindex="-1"><a class="header-anchor" href="#_4-3-git基本流程操作" aria-hidden="true">#</a> 4.3 git基本流程操作：</h3><p>1、变动 Repo 目录中的原有内容。所谓的 “变动” 包括：新增文件、修改原有文件内容、删除已有文件等。对于你的 “变动” 行为，在 GitKraken 中你可以观察到它们：如：在工作目录xxx中创建一个hello.txt文件</p><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211228154912015.png" alt="image-20211228154912015"></p><p>2、然后执行 <strong>git add</strong> 命令。<strong>git add</strong> 命令会把文件内容加入 Git 系统的『<strong>暂存区</strong>』（也叫索引区，Index）</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> <span class="token function">add</span>  文件1  文件2
<span class="token function">git</span> <span class="token function">add</span>  目录   <span class="token comment">##目录不能为空</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在 GitKraken 的图形化界面操作中，对应操作是点击：Stage File</p><p>3、接着就可以执行 <strong>git commit</strong> 命令，将文件的内容存入『<strong>本地仓库</strong>』（.git）</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token variable">$git</span> commit <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>. <span class="token parameter variable">-m</span> <span class="token punctuation">[</span>message<span class="token punctuation">]</span>   <span class="token comment">##必须添加描述信息，如果是文件夹，文件夹不能为空 </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211228155355278.png" alt="image-20211228155355278"></p><h3 id="_4-4-git-中文件的受管状态" tabindex="-1"><a class="header-anchor" href="#_4-4-git-中文件的受管状态" aria-hidden="true">#</a> 4.4 Git 中文件的受管状态</h3><p>Git 会将文件（文件夹）的状态分成以下 3 类：</p><ul><li><p><strong>tracked</strong>：被追踪</p><p>tracked 状态意味着 Git 正在关注着这个文件。你对这个文件的任何改动，都会被 Git 发现。Git 会进一步要求你提交你的改动，或撤销你的改动。</p></li><li><p><strong>ignored</strong>：被忽略的</p><p>ignored 状态意味着 Git 完全不管这个文件，在 Git 看来它就跟不存在一样。</p></li><li><p><strong>untracked</strong>：不被追踪的</p><p>untracked 状态是所有文件的初始状态</p></li></ul><p>这里有 2 点需要强调的是：</p><ol><li>所有的文件的初始状态都是 <strong>untracked</strong> 。</li><li>在正常情况下，<strong>文件不应该长期处于 untracked 状态</strong>，应尽快转变为 <strong>tracked</strong> 或 <strong>ignored</strong> 。</li></ol><p>在 GitKraken 中如果你 “动” 过 Repo 目录中的文件的话，你所看到的图形化信息类似如下</p><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211228155855572.png" alt="image-20211228155855572"></p><p>对于新创建的文件，它们都是处于 <strong>untracked</strong> 状态的，接下来它们应该尽快通过下述 2 种方法之一切换成 <strong>ignored</strong> 状态，或 <strong>tracked</strong> 状态。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>untracked 
└──&gt; ignored 

必须先在 Repo 文件夹中创建一个名为 .gitignore 的文件（必须是这个名字），
然后把要忽略的文件逐一列在这个文件中，一个文件一行，支持通配符。
untracked 
└──&gt; tracked 

可以使用 git add + git commit 命令，将它提交给 Git 监管即可。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-5-新增一个文件的历史版本" tabindex="-1"><a class="header-anchor" href="#_4-5-新增一个文件的历史版本" aria-hidden="true">#</a> 4.5 新增一个文件的历史版本</h3><p><strong>git add</strong> + <strong>git commit</strong> 的作用简单来说，就是将一个文件的当前内容提交给 Git ：</p><ul><li>对于 untracked 状态的文件（即新增的文件），提交后会变成 tracked 状态；</li><li>对于 tracked 状态的文件（即原有的文件），其历史版本记录则会演进一步。</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">git</span> <span class="token function">add</span> <span class="token string">&quot;hello.txt&quot;</span>     不管是添加这个文件，还是修改这个hello.txt文件,都要先添加到 <span class="token function">git</span> <span class="token function">add</span> 添加到暂存区
$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">&quot;message&quot;</span> 提交到git本地仓库
$ <span class="token function">git</span> commit 文件名 <span class="token parameter variable">-m</span> <span class="token string">&quot;message&quot;</span> 对于一个修改的文件提交到git本地仓库
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于一次『提交』而言，<strong>提交消息（message）是必须的</strong> 。否则，Git 会拒绝你的这次提交。对应的图形界面操作如下：</p><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211228161847808.png" alt="image-20211228161847808"></p><p><code>git commit</code>『<strong>只会</strong>』将暂存区的文件的内容提交至本地仓库进行保存。</p><h3 id="_4-6-git-的核心思想-一致性" tabindex="-1"><a class="header-anchor" href="#_4-6-git-的核心思想-一致性" aria-hidden="true">#</a> 4.6 Git 的核心思想：一致性</h3><p>当你改动了工作区（硬盘上）的文件的内容之后，你可以使用 <strong>git status</strong> 命令查看文件的状态。 在当前工作区打开git Bash here</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> status
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211228162218780.png" alt="image-20211228162218780"></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>这里除了能看到 <span class="token class-name">Git</span> 监控到的文件的变动 \`modified<span class="token operator">:</span> hello<span class="token punctuation">.</span>txt\` 之外，在这条信息的上面，你还能看到 <span class="token class-name">Git</span> 为你给出的 <span class="token number">2</span> 条建议：接下来请使用 <span class="token operator">*</span><span class="token operator">*</span>git add <span class="token generics"><span class="token punctuation">&lt;</span>file<span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>*<span class="token operator">*</span> 命令，或使用 <span class="token operator">*</span><span class="token operator">*</span>git checkout <span class="token operator">--</span> <span class="token generics"><span class="token punctuation">&lt;</span>file<span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>*<span class="token operator">*</span> 命令。

这两条建议的背后，体现出 <span class="token class-name">Git</span> 的一个核心『关注点』：<span class="token class-name">Git</span> 希望你能保持<span class="token operator">*</span><span class="token operator">*</span>工作区和本地仓库的一致性<span class="token operator">*</span><span class="token operator">*</span>

在初始状况下，工作区和本地仓库的内容是一致的，当你改动工作区的文件后，工作区和本地仓库的内容就不再一致了<span class="token punctuation">,</span>对于此情况，<span class="token class-name">Git</span> 希望你将它们重新『调整』成一致，至于如何『调整』，有 <span class="token number">2</span> 种方案（这也就是 <span class="token class-name">Git</span> 对你给出的 <span class="token number">2</span> 条二选一的建议）：
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>1、使用 <code>git add &lt;file&gt;...</code> 命令（及后续的 <code>git commit</code> 命令），将你对工作区的改动提交到本地仓库。这样，工作区和本地仓库将会重新一致。这也就意味着，本地仓库的版本将向前演进。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> <span class="token function">add</span> <span class="token string">&quot;hello.txt&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2、使用 <code>git checkout -- &lt;file&gt;...</code> 命令用本地仓库（的最新、最近版本）的内容覆盖你的工作区的内容。这样，工作区和本地仓库将会重新一致。这也就意味着，你的工作区的内容的变动将会被覆盖、舍弃</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> checkout -- <span class="token string">&quot;hello.txt&quot;</span>  <span class="token comment">##要注意中间的 -- 否则就是切换分支了</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_4-7-gitignore文件" tabindex="-1"><a class="header-anchor" href="#_4-7-gitignore文件" aria-hidden="true">#</a> 4.7 .gitignore文件</h3><p>之前已经提到过，<strong>.gitignore</strong> 是用于屏蔽某些文件被纳入到 Git 管理范围下的配置文件。</p><p>简单来说，<strong>.gitignore</strong> 文件就是一个『<strong>黑名单</strong>』，在其中列举的文件都不会被 Git 管理，Git 不会关注这些文件的创建、删除、改动，也不会将它们存入到本地版本库，更不会将它们上传到远程仓库</p><h4 id="_1-创建-gitignore文件" tabindex="-1"><a class="header-anchor" href="#_1-创建-gitignore文件" aria-hidden="true">#</a> 1.创建 .gitignore文件</h4><blockquote><p>注意</p><p>.gitignore 文件必须叫 .gitignore ，一定不能错，扩展名不是.txt，这个文件名就是 .gitignore</p></blockquote><h4 id="_2-语法" tabindex="-1"><a class="header-anchor" href="#_2-语法" aria-hidden="true">#</a> 2. 语法</h4><p><strong>.gitignore</strong> 文件的基本语法：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">##：表示注释</span>
/：目录层级
*：通配符
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例如：</p><p>1、忽略所有后缀名为 log 的文件，无所谓文件名。无论它位于什么层次结构。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>*.log
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2、忽略『根目录』下的 target 文件夹</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>/target/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里最后的 / 非必须。不过个人建议还是加上，因为可以暗示出它是一个文件夹。</p><p>3、忽略所有名为 target 的文件夹。无论它位于什么层次结构中。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>target/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>注意：</p><p>1、.gitignore<code> 配置文件的根目录就是当前 Git 工程目录。</code>.gitignore 配置只对当前 Git 工程有效。</p><p>2、在配置语句的前后面添加空格、Tab、注释等，会导致当前行的配置语句失效。所以，不要添加非必要的空白符。</p><p>3、配置语句对已经 add、commit 的文件无效</p></blockquote><h3 id="_4-8-取出历史版本" tabindex="-1"><a class="header-anchor" href="#_4-8-取出历史版本" aria-hidden="true">#</a> 4.8 取出历史版本</h3><p>从本地版本库中取出文件只需要一个指令</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> checkout <span class="token punctuation">[</span> 版本标识 <span class="token operator">|</span> 标签 <span class="token punctuation">]</span> <span class="token operator">&lt;</span>文件<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>, <span class="token operator">&lt;</span>文件<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>, <span class="token punctuation">..</span>.
如：
<span class="token function">git</span> checkout 5bff6bad18891ade78144c364f738500c149d0d8   <span class="token comment">##代表版本标识，每次提交之后都会有一个commit:版本标识</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要特别提醒的是，磁盘文件夹中的文件会被取出的文件『<strong>覆盖</strong>』（覆盖、覆盖），因此你对该文件作出的修改会丢失</p><p>例如，本地版本库中的文件有是 20 行的版本是v2，你把本地的文件被你改成 60行（未提交），执行 git checkout 到v2之后，你的本地文件会变成 20行。</p><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211228170141181.png" alt="image-20211228170141181"></p><p>取回历史版本之后，如何再回到master呢？双击master即可</p><h3 id="_4-9-从-git-中删除文件" tabindex="-1"><a class="header-anchor" href="#_4-9-从-git-中删除文件" aria-hidden="true">#</a> 4.9 从 git 中删除文件</h3><p><strong>git rm</strong> 用于删除文件，删除行为分为『弱删除』和『强删除』。</p><ul><li><p><strong>git rm --cache</strong> 是『弱』删除。</p><p>它表示让 Git『<strong>不再监管</strong>』某文件/文件夹，而该文件/文件夹在磁盘上『<strong>仍存在</strong>』。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span>  <span class="token function">rm</span> <span class="token string">&quot;hello.txt&quot;</span> <span class="token parameter variable">--cache</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>git rm</strong> 是强删除</p><p>它表示告知 Git『<strong>不再监管</strong>』某文件/文件夹的同时，还从硬盘上『<strong>删除</strong>』此文件/文件夹</p></li></ul><h3 id="_4-10-撤销" tabindex="-1"><a class="header-anchor" href="#_4-10-撤销" aria-hidden="true">#</a> 4.10 撤销</h3><p>Git 中的撤销功能很强大，能应对多种常见、不常见场景，因此代价就是对初学者而言学习门槛很高，并且有很多特殊用法用不上，因此，通常各个图形化工具会做出简化，仅仅暴露常见、常用的撤销功能。</p><p>在 GitKraken 中执行撤销常见 2 处：</p><p>1、在工作区上方有一个 “垃圾桶” 的图标。</p><p>2、在工作区和暂存区的文件身上点击鼠标右键，有一个 “Discard changes” 选项。</p><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211228172511807.png" alt="image-20211228172511807"></p><h4 id="_1-撤销所有未提交变动" tabindex="-1"><a class="header-anchor" href="#_1-撤销所有未提交变动" aria-hidden="true">#</a> 1. 撤销所有未提交变动</h4><p>当你点击 “垃圾桶” 的图标时，你的工作区和暂存区的内容（即，所有未提交的内容），会全部撤销。这意味着，你的工作区的内容将会回到当初你什么都没动过的时候的样子，即，上一轮提交之后的样子</p><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211228172654141.png" alt="image-20211228172654141"></p><p>当然，GitKraken 会想你确认一下，怕你是手抖点错了。这个图形化界面操作的背后，执行的是 <strong>git reset --hard</strong> 命令。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> reset <span class="token parameter variable">--hard</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p><strong>hard</strong> 方式的 <strong>git reset</strong> 会同时撤销你工作区和暂存区中的内容（discard all changes）。撤销后，你的项目就一步到位地回到『当初什么都没动过的样子』</p></blockquote><h4 id="_2-单独撤销某文件的未提交变动" tabindex="-1"><a class="header-anchor" href="#_2-单独撤销某文件的未提交变动" aria-hidden="true">#</a> 2.单独撤销某文件的未提交变动</h4><p>这个功能执行很简单，如果你想撤销你对某个文件的变动（注意是修改了文件的内容），对于增加的文件，右键是没有这个选项的。那么在它身上鼠标右键，点击 “Discard changes” 。点完之后，这个文件就恢复成没动过之前的样子。</p><p>这个操作背后执行的命令是： <strong>git checkout -- &lt;文件名&gt;</strong> 。</p><blockquote><p>注意</p><p>不是 git reset 什么的。这个命令从版本库中的最新、最近版本来覆盖工作目录中的内容，即恢复成你变动之前的样子</p></blockquote><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211228173901492.png" alt="image-20211228173901492"></p><h4 id="_3-撤销刚才的提交" tabindex="-1"><a class="header-anchor" href="#_3-撤销刚才的提交" aria-hidden="true">#</a> 3.撤销刚才的提交</h4><p>不排除这种情况，你已经提交、或手抖提交了，然后发现，本不该提交的 ......</p><p>执行 <strong>git reset --soft HEAD~1</strong> 命令就可以用来实现撤销已提交的变更。HEAD也可以小写</p><blockquote><p>TIP</p><p><strong>git reset --soft HEAD~1</strong> 命令的本意是：移动 HEAD 到指定的上一次的提交上。而 HEAD 指针是你的分支的逻辑上的（当前的）终点。</p><p>这里有 2 点注意的：</p><p>1、HEAD~1 的含义就是最新版本的上一个版本，毫无疑问，还可以有 HEAD~2 、HEAD~3 等等，表示最新版本的上上个版本、上上上个版本。</p><p>2、你所提交的东西（也就是你想撤销的代码），会被 Git 放到暂存区，给你多一次考虑的机会，是真得删除掉，还是改改再提交。</p></blockquote><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211228174759844.png" alt="image-20211228174759844"></p><p>此时撤销到暂存区，当然如果你不需要修改的内容，可以执行删除</p><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211228175050963.png" alt="image-20211228175050963"></p><h4 id="_4-比较文件差异" tabindex="-1"><a class="header-anchor" href="#_4-比较文件差异" aria-hidden="true">#</a> 4. 比较文件差异</h4><p>对比『<strong>工作空间中的文件</strong>』与当前 Git 本地仓库中的最新、最近的版本版（也就是 <strong>HEAD</strong> 版本）之间的差异</p><p>主要是工作区和暂存区文件内容的比较，使用命令 git diff &lt;文件名&gt;</p><p>例如：修改一个文件world.txt，将内容提交到暂存区</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> <span class="token function">diff</span> world.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211228180258689.png" alt="image-20211228180258689"></p><p>说明： ---表示变动前的版本，+++表示改了之后的版本</p><blockquote><p>这种方式查看很不方便，推荐使用其他的第三方工具，如小乌龟等</p></blockquote><h2 id="_5-git进阶" tabindex="-1"><a class="header-anchor" href="#_5-git进阶" aria-hidden="true">#</a> 5.git进阶</h2><h3 id="_5-1-分支" tabindex="-1"><a class="header-anchor" href="#_5-1-分支" aria-hidden="true">#</a> 5.1 分支</h3><p>版本的提交不可能『依次进行，以便形成一条直线型的提交历史记录』，原因有二</p><p>1、<strong>并行式开发</strong>：有两个以上的开发者在对同一个项目进行并行式开发。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>版本库 1            版本库2
A &lt;--- B &lt;--- C     A &lt;--- B &lt;--- D

         C
        /
A &lt;--- B  
        \\
         D
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、<strong>修复旧版本中的 bug</strong>：一方面要修复旧版本中的 bug，而与此同时又要创建和发布新的版本。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>前期
A &lt;--- B &lt;--- C &lt;--- D

修复 bug 之后
         C &lt;--- D
        /
A &lt;--- B  
        \\
         E
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有人将分支比喻成泳道</p><p>分支可以看作是开发过程当中的并行线，我们可以把提交图想象成游泳池中的泳道：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>       E              release
        /
A &lt;--- B &lt;--- C &lt;--- D  master
               \\
                F       test
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在一个 Git 版本库中，总是唯一存在着一个『<strong>活动分支</strong>』（也叫『<strong>当前分支</strong>』）。我们可以用 <strong>branch</strong> 命令（不带选项）来列出所有的分支。Git 会用星号（*）凸显出当前活动分支。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span>  branch
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在 GitKraken 中当前分支名字前面有一个 ✓符号。</p><h3 id="_5-2-分支的基本操作" tabindex="-1"><a class="header-anchor" href="#_5-2-分支的基本操作" aria-hidden="true">#</a> 5.2 分支的基本操作</h3><p>1、查看分支</p><p>通过 <strong>git branch</strong> 可以看到 Git 仓库的所有分支。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> branch
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当执行 git init 指令的时候，Git 就会自动产生一个名为 <strong>master</strong> 的分支：主分支。主分支是默认的、初始的。</p><p>2、创建分支</p><p>创建新的分支，也是使用 <strong>git branch</strong> 命令。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> branch 新分支名 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>3、切换分支</p><p>建立分支后，可以通过 <strong>git checkout</strong> 命令来切换当前分支：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> checkout <span class="token operator">&lt;</span>分支名<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>4、删除分支</p><p>删除分支使用：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> branch <span class="token parameter variable">-d</span> <span class="token operator">&lt;</span>被删除分支名<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果在删除一个分支时，自己还未转移到其他分支上，git 会拒绝删除操作。如果坚持要删除的话，则使用 <strong>-D</strong> 选项替换 <strong>-d</strong> 选项。</p><p>一般情况下，分支应该合并到另一个分支。如果要删除还未合并的分支，Git 会显示错误信息，并拒绝删除。当然你也通过 <strong>-D</strong> 选项来强制删除</p><h3 id="_5-3-分支合并" tabindex="-1"><a class="header-anchor" href="#_5-3-分支合并" aria-hidden="true">#</a> 5.3. 分支合并</h3><p>在大多数情况下，项目的分支都会被合并到主（master）分支。合并项目分支需要使用 <strong>git merge</strong> 命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> merge <span class="token operator">&lt;</span>另一个分支名<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>该命令会把『另一个分支』合并到当前分支，合并后的 Commit 属于当前分支。</p><blockquote><p>你站在哪个分支上？当前分支是谁？</p><p>考虑这个问题的关键点在于：合并分支是合并 “进来” 。体会下，什么叫合 “进” 来。</p><p>假设是 A 和 B 两个分支合并，这里就有 2 种情况：</p><ul><li>站在 A 分支上（你的当前分支是 A ），把 B 分支合并 “进来” 。</li><li>站在 B 分支上（你的当前分支是 B ），把 A 分支合并 “进来”。</li></ul><p>这 2 种情况都合情合理合法，关键是你要考虑清楚你需要的是哪一种情况。</p></blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>前期：
A &lt;--- B &lt;--- E    master
        \\
         C &lt;--- D  feature

后期：
A &lt;--- B &lt;--- E &lt;--- F  master
        \\           /
         C &lt;------ D  feature
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结合上面的那个问题，从图上（合并的箭头方向）可以看到，你是站在 master 分支上，把 feature 分支合并了 “进来” 。</p><blockquote><p>回顾一下</p><p>如果合并后想反悔，那么可以执行之前所学的 git reset --soft HEAD~1，回到提交前，然后放弃提交。</p></blockquote><p>合并所产生的节点和普通节点有一个很重要的区别：</p><ul><li>普通节点只有唯一的父节点，表示为 <code>HEAD^1</code> ；</li><li>合并节点有 2 个父节点，分别表示为 <code>HEAD^1</code> 和 <code>HEAD^2</code></li></ul><h3 id="_5-4-合并的冲突" tabindex="-1"><a class="header-anchor" href="#_5-4-合并的冲突" aria-hidden="true">#</a> 5.4 合并的冲突</h3><p>Git 的设计目标之一就是为了能够让开发者之间的分布式协作变得尽可能容易一些。因此从很大程度上来说，merge 命令能自动对分支进行合并，完全不需要用户交互。</p><p>当两个分支对于同一个文件做出了不同的操作时，可能会出现冲突，而且此时，Git 无法自动 “帮” 你合并。最常见的冲突情况有 2 种：</p><p>1、两个分支对于<strong>同一个文件</strong>做出了修改</p><p>那么你在合并这两个分支时，Git 无法自己决定 “合并后保留的是哪个分支上的内容（而废弃另一个），亦或者是两个分支上的都要保留” ？这种情况，就需要人来裁决</p><p>2、一个分支对一个文件执行了删除操作，而另一个分支上这个文件还在，仅仅只是内容有变动。</p><p>那么你在合并这两个分支时，Git 无法自己决定 “合并后这个文件到底是应该删除，还是留着” ？这种情况也需要人来裁决。</p><blockquote><p>补充一点，并非对于同一个文件的修改，都会造成冲突。比如，如果两个分支是对同一个文件的不同位置做出了修改（注意和上述第一种情况的区别），Git 自己也会自动合并：合并后的内容会同时采纳两个分支上的操作。</p></blockquote><p>冲突合并就失败，显示信息如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">git</span> merge dev

Auto-merging foo.txt
CONFLICT <span class="token punctuation">(</span>content<span class="token punctuation">)</span>: Merge conflict <span class="token keyword">in</span> foo.txt
Automatic merge failed<span class="token punctuation">;</span> fix conflicts and <span class="token keyword">then</span> commit the result.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时，如果执行 <strong>git status</strong> 命令，会看到 git 提醒你，它无法完成自动合并，需要你手动进行编辑，并且要求你在编辑之后</p><p>执行<strong>git add 文件名</strong>保存到暂存区 ，然后执行 **git commit -m “xxx” ** 来提交到本地仓库</p><h3 id="_5-5-快速合并" tabindex="-1"><a class="header-anchor" href="#_5-5-快速合并" aria-hidden="true">#</a> 5.5 快速合并</h3><p>所谓的快速合并指的是在执行 git merge 命令时多带一个 <strong><code>--ff</code></strong> 的参数，它是 Fast Forward 这两个单词的首字母。有 “快速” 合并自然就有 “非快速” 合并：<code>--no-ff</code> 。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> merge 分支名 <span class="token parameter variable">--ff</span>
<span class="token function">git</span> merge 分支名 --no-ff
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>警告</p><p>不是每次都可以进行快速合并的，如果当前的分支和另一个分支没有内容上的差异，就是说当前分支的每一个提交(commit)都已经存在另一个分支里了，此时就可以快速合并，当然也可以执行非快速合并</p></blockquote><p>例1：master分支上有了5次提交，然后基于master创建分支test，并在test上进行3次提交，此时切换到master分支上就可以“快速合并”test分支，因为test分支上含有master分支的所有内容。</p><p>例2：master分支上有了5次提交，然后基于master创建分支test。如果是test分支做了三次提交，然后切换到master分支上对工作区的内容做了修改操作，然后提交。也就是说这个时候test和master分支的内容有差异，此时切换到master分支上去合并test分支就不能进行快速合并。</p><blockquote><p>Git 在合并时的默认行为，先看当前的情况是否符合快速合并的条件，如果符合就进行快速合并，否则就进行非快速合并，当然，你可以通过强行指定 --no-ff 告诉 Git ，在合并时一定是按 “非快速合并” 进行合并。</p></blockquote><p>实验1：</p><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211228201350723.png" alt="image-20211228201350723"></p><p>在上图中，feature 分支上的内容比 master 分支的内容只多不少，即 feature 分支完全 “涵盖” 了 master 分支的内容。这种情况下，执行 git merge --ff 过程效果如下，注意是master分支去合并feature分支</p><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211228202127245.png" alt="image-20211228202127245"></p><p>合并之后效果，分支的提交历史也没有“开叉”，即没有多个父提交节点</p><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211229103709729.png" alt="image-20211229103709729"></p><p>实验2：</p><p>在上一个实验的基础上，master分支和feature分支内容没有差异，版本都是c3。在feature上进行3次提交，然后切换到master分支上以<strong>非快速合并</strong>的方式去合并feature。</p><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211229104122394.png" alt="image-20211229104122394"> <img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211229104145756.png" alt="image-20211229104145756"></p><p>这时候，同快进式合并不同的是，在c3处产生了“开叉”，然后新生成了一个commit “Merge branch &#39;feature&#39;”节点，</p><blockquote><p>注意：</p><p>git merge 默认行为，在你使用 git merge 命令没有指定合并方式时，Git 总是先判断当前是否能进行快速合并，如果不行，它再执行非快速合并。快速合并只适用于部分合并情况，而非快速合并适用于所有的合并情况，快速合并会让历史记录中 “省” 一个合并节点。</p></blockquote><h3 id="_5-6-变基" tabindex="-1"><a class="header-anchor" href="#_5-6-变基" aria-hidden="true">#</a> 5.6 变基</h3><p>git rebase 能实现和 git merge 同样的功能，它可以以另一种方式来实现 “分支合并” 的效果。</p><h4 id="_5-6-1-merge-和-rebase" tabindex="-1"><a class="header-anchor" href="#_5-6-1-merge-和-rebase" aria-hidden="true">#</a> 5.6.1.merge 和 rebase</h4><p>假设我们有两个分支（master 和 feature）。feature 是基于 master 的 C1 节点建立的分支，然后开发人员分别在两个分支各自开发</p><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211229111903965.png" alt="image-20211229111903965"></p><p>一个人在 C1 版本基础上开发出了 C2 版本；另一个人在 C1 基础上开发出了 C3 版本</p><p>现在我们想要把 feature 分支开发的内容合并到 master，使用 merge 命令</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">git</span> checkout master
$ <span class="token function">git</span> merge feature             <span class="token comment">##按esc到命令模式，:wq!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>复习</p><p>merge 命令的使用是 “站在 master 分支” 的角度上来看，将 feature 分支的内容 “纳入” 到 master 分支。master 分支会演进出一个新的版本</p></blockquote><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211229112212527.png" alt="image-20211229112212527"></p><p>从整体来看，merge 命令执行之后，会在之前的相关的 3 个版本节点之外生成一个新的节点 这个新节点将会是 master 线路上的最新的 “终点”</p><p>对于同样的初始情况，如果我们使用 rebase 命令会有什么不同。git rebase 的正确使用方式和 git merge 有一点是完全相反的：</p><ul><li>使用 git merge 时，你是站在 A 分支，考虑把 B 分支 “合并进来”；</li><li>使用 git rebase 时，你是站在 B 分支，考虑把 B 分支的 “基” 变成 A 的某个节点（通常是端点，即，最新的节点）。</li></ul><p>你要执行的命令如下（再次强调，你是站在 feature 分支上）：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">git</span> checkout feature
$ <span class="token function">git</span> rebase master
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在 GitKraken 中等价的操作如下：</p><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211229112918484.png" alt="image-20211229112918484"></p><blockquote><p>实际开发中，master分支有提交的内容，feature分支上有提交的内容，此时应该是要切换到master分支，合并feature的内容，然后在切换到feature分支，执行变基到master</p><p>整个流程的总而言之一句话：master merge feature ，feature rebase on master</p></blockquote><h3 id="_5-7-git-stash使用" tabindex="-1"><a class="header-anchor" href="#_5-7-git-stash使用" aria-hidden="true">#</a> 5.7 Git Stash使用</h3><h4 id="_5-7-1-git-stash-存放-的作用" tabindex="-1"><a class="header-anchor" href="#_5-7-1-git-stash-存放-的作用" aria-hidden="true">#</a> 5.7.1 Git Stash(存放) 的作用</h4><p>在开发过程中，我们经常会遇到如下两种情况：</p><ul><li>开发到一半，需要同步远端代码</li><li>手头的工作被打断，需要先做别的需求</li></ul><p>上述两种情况所面对的问题，都不单单是 pull、commit、push 就能解决，或者说，使用 pull、commit、push 并非最有解。这里我们可以通过引入 <strong>git stash</strong> 来解决这些问题。</p><p><strong>git stash</strong> 用于想要保存当前的修改，但是想回到之前最后一次提交的干净的工作仓库时进行的操作。<em>git stash</em> 将本地的修改保存起来，并且将当前代码切换到 HEAD 提交上</p><blockquote><p>简单来说</p><p>使用 git stash 还你一个干净的工作目录！</p></blockquote><p>通过 git stash 存储的修改列表，可以通过 <strong>git stash list</strong> 查看。<strong>git stash show</strong> 用于校验，<strong>git stash apply</strong> 用于重新存储。直接执行 git stash 等同于 <strong>git stash save</strong></p><blockquote><p>TIP</p><p>当然，如果是通过 Git 的图形化客户端进行操作，那么对于这些命令就无需花费太多时间和精力进行记忆。采用图形工具，点击Stash按钮，这会出现正方形的虚线框</p></blockquote><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211229114548519.png" alt="image-20211229114548519"></p><p>最新的存储保存在 refs/stash 中。老的存储可以通过相关的参数获得，例如 <code>lstash@{0}</code> 获取最新的存储，<code>stash@{1}</code> 获取次新，存储可以直接通过索引的位置来获得 <code>stash@{n}</code></p><p>图形化操作：点击某个正方形虚线框，点击Pop按钮，可以获得，然后再add，再commit</p><h4 id="_5-7-2-开发到一半-同步远端代码" tabindex="-1"><a class="header-anchor" href="#_5-7-2-开发到一半-同步远端代码" aria-hidden="true">#</a> 5.7.2 开发到一半，同步远端代码</h4><p>当你的开发进行到一半，但是代码还不想进行提交，然后需要同步去关联远端代码时。</p><ul><li>如果你本地的代码和远端代码没有冲突时，可以直接通过 git pull 解决。</li><li>但是如果可能发生冲突怎么办？直接 <code>git pull</code> 会拒绝覆盖当前的修改。</li></ul><p>遇到这种情况，需要先 stash 本地的代码，进行 pull，然后再 pop 出本地代码</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> stash
<span class="token function">git</span> pull
<span class="token function">git</span> stash pop
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_6-git高级" tabindex="-1"><a class="header-anchor" href="#_6-git高级" aria-hidden="true">#</a> 6.git高级</h2><h3 id="_6-1-git远程仓库" tabindex="-1"><a class="header-anchor" href="#_6-1-git远程仓库" aria-hidden="true">#</a> 6.1 git远程仓库</h3><p>远程（remote）版本库也叫上游（origin）版本库</p><p>通常我们并不常亲自建立远程仓库，而是委托给『第三方』。常见的操作是，先在第三方上创建『远程 Git 文档库』，然后复制（Clone）出一个『本地 Git 文档库』</p><h3 id="_6-2-在托管网站上创建远程仓库" tabindex="-1"><a class="header-anchor" href="#_6-2-在托管网站上创建远程仓库" aria-hidden="true">#</a> 6.2 在托管网站上创建远程仓库</h3><p>常见的代码托管仓库有：</p><ul><li>国外：github、gitlib</li><li>国内：gitee、Coding</li></ul><p>在托管网站上创建项目后，通常项目目录下是空的，可以通过以下 2 种途径初始化该项目：</p><h3 id="_6-3-克隆远程仓库" tabindex="-1"><a class="header-anchor" href="#_6-3-克隆远程仓库" aria-hidden="true">#</a> 6.3 克隆远程仓库</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> clone <span class="token operator">&lt;</span>远程文档库的路径<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>本地文档库的文件夹名称<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>更具体的的格式为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git clone &lt;http://Web服务器地址/远程文档库路径&gt; &lt;本地文档库名称&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>例如:在git bash窗口执行如下</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> /d
<span class="token function">mkdir</span> repo2
<span class="token builtin class-name">cd</span> repo2
<span class="token function">git</span> clone https://gitee.com/xiaokongming/hospital-repo.git   <span class="token comment">#克隆到当前目录  网址是HTTPS方式</span>
<span class="token function">git</span> clone git@gitee.com:xiaokongming/hospital-repo.git      <span class="token comment">#SSH方式</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>对于SSH这种方式要在本地电脑生成秘钥对，把公钥拷贝到中央仓库，和账户绑定在一起。如果是多人团队开发，则需要点击某个仓库，然后点击”管理“，点击”部署公钥管理“，将小组成员的公钥添加进去</p><p>同样对应HTTPS方式，如果是多人团队开发，则需要点击某个仓库，然后点击”管理“，点击“仓库成员管理”，然后点击“开发者管理”，“添加仓库成员”，添加小组成员的gitee账号即可，在日常工作中，<strong>git clone</strong> 命令一个项目通常只会执行一次</p></blockquote><h3 id="_6-4-推送远程仓库" tabindex="-1"><a class="header-anchor" href="#_6-4-推送远程仓库" aria-hidden="true">#</a> 6.4 推送远程仓库</h3><p>当我们完成对本地文档库的修改，可以将这些修改『<strong>推送</strong>』到远程 Git 仓库：</p><p>如果是第一次推送一个工程到远程仓库</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> remote <span class="token function">add</span> origin 远程仓库地址
如：
<span class="token function">git</span> remote <span class="token function">add</span> orign https://gitee.com/xiaokongming/three.git
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> push origin <span class="token punctuation">[</span>分支名称<span class="token punctuation">]</span>
如：
<span class="token function">git</span> push origin master
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>git push</strong> 有两种模式：</p><ul><li>推送本地『<strong>所有</strong>』分支，</li><li>推送『<strong>当前</strong>』分支。</li><li>如多使用第一种模式，配置：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> config <span class="token parameter variable">--global</span> push.default matching    <span class="token comment">#第一种配置  </span>
<span class="token function">git</span> config <span class="token parameter variable">--global</span> push.default simple      <span class="token comment">#第二种配置  Git2.0  默认</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>第二种模式更安全，推荐使用第二种。</p><p>无论哪种传送模式，只要执行 <strong>git push --all</strong> 都是推送所有分支</p><p>实验操作：</p><p>如：在本地添加一个文件，</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> <span class="token function">add</span>  <span class="token string">&quot;add.txt&quot;</span>   <span class="token comment">#提交到本地暂存区</span>
<span class="token function">git</span>  commit <span class="token parameter variable">-m</span> <span class="token string">&quot;v6&quot;</span>
<span class="token function">git</span> push origin master 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-5-推送冲突" tabindex="-1"><a class="header-anchor" href="#_6-5-推送冲突" aria-hidden="true">#</a> 6.5 推送冲突</h3><p>如果远程分支并非你一个人独有，那么很有可能由于别人的提交，导致远程分支向前演进，从而导致 push 失败。此时需要『<strong>三步合并法</strong>』解决冲突问题。</p><ul><li>从远程 Git 文档库取回当前所在分支的最新数据。</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> pull origin master <span class="token operator">|</span> 其它分支
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>把远程 Git 文档库的分支合并到本地 Git 的分支。这一步可能会出现冲突。解决冲突，合并代码。</p></li><li><p>再推送</p></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> push origin master <span class="token operator">|</span> 其它分支
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_6-6-小贴士" tabindex="-1"><a class="header-anchor" href="#_6-6-小贴士" aria-hidden="true">#</a> 6.6 小贴士</h3><p>1、xxx 只和 xxx 玩，yyy 只和 yyy 玩：</p><p>当你要推送（push，逻辑上就是上传）本地的 xxx 分支时，你上传的目的地一定是远程的 xxx 分支；</p><p>当你要拉取（push，逻辑上就是下载）远程的 yyy 分支时，你下载的目的地一定是本地的 yyy 分支；</p><p>理论上虽然可以，但是实际上我们并不会让本地的 xxx 分支和远程的 yyy 分支有推拉关系。即，本地 xxx 分支只和远程 xxx 分支『玩』，本地 yyy 分支只和远程的 yyy 分支『玩』。</p><p>2、推拉（push/pull）都是在更新：</p><p>推送（push）操作的执行的潜在前提是：你的本地 xxx 分支上的代码一定更『新』（版本更高），否则，你为什么要上传呢？</p><p>拉取（pull）操作的执行的潜在前提是：你的远程 xxx 分支上的代码一定更『新』（版本更高），否则，你为什么要下载呢？</p><p><strong>推拉都是在更新，只是『方向』不同</strong>：推送，是用本地 xxx 分支更新远程 xxx 分支；拉取，是用远程 xxx 分支更新本地 xxx 分支。</p><p>3、合理使用『简称』少费口舌：</p><p>通过 git push 命令推送本地 xxx 分支代码到远程 xxx 分支，实现远程 xxx 分支的代码的更新，简称：通过推送 xxx 分支来更新远程 xxx 分支。</p><p>通过 git pull 命令拉取远程 yyy 分支代码到本地 yyy 分支，实现本地 yyy 分支的代码的更新，简称：通过拉取 yyy 分支来更新本地 yyy 分支。</p><p>4、故意推拉『旧代码』是为了放弃：</p><p>可以推送（上传）旧代码，在此之前，你的远程 xxx 分支的代码更新，版本更高，而你推送（上传）的旧代码会覆盖掉远程的新代码；</p><p>也可以拉取（下载）旧代码，在此之前，你的本地 yyy 分支的代码更新，版本更高，而你拉取（下载）的旧代码会覆盖掉本地新代码；</p><p>通常情况下，你不太可能会用旧代码更新新代码，如果你这么干了，意味着你是想废弃新代码中『新』的那部分内容</p><h2 id="_7-git-工作流" tabindex="-1"><a class="header-anchor" href="#_7-git-工作流" aria-hidden="true">#</a> 7.git 工作流</h2><p>Git 最大的优点同时也是它的最大的缺点：极具灵活性。这种灵活抬高了初学者的学习门槛。为此，有经验的程序员和大型机构结合软件开发的流程为 git 总结-提炼出了固定的使用方式，这中特定的使用顺序和方法被称为 <strong>工作流</strong> 。</p><p>Atlassian 公司推荐一种基于 <strong>git rebase</strong> 命令的 Git 工作流，这种工作流与 github 工作流的却别在于，『处理代码冲突』的工作从项目管理者转交到了代码提交者手里，项目提交者必须要保证自己的新代码与 master 分支合并后必须是无误的（至少是不耽误 master 分支原有代码运行的），再发起 pull request 。</p><h3 id="_7-1-核心规则" tabindex="-1"><a class="header-anchor" href="#_7-1-核心规则" aria-hidden="true">#</a> 7.1 核心规则</h3><p>这种基于 <strong>git rebase</strong> 的工作流核心准则只有 2 条：</p><p>1、让你的本地的 master 和远程仓库的 master『在一起』；</p><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211229154205947.png" alt="image-20211229154205947"></p><p>如何让它俩在一起？</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>1. 切换到 master 分支
2. 执行 git pull
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>2、让你的工作分支始终保证是『基于你的本地最新 master』的</p><p><img src="https://apaiimages.oss-cn-guangzhou.aliyuncs.com/MD/image-20211229154306087.png" alt="image-20211229154306087"></p><p>如何让工作分支基于最新的 master ？</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>1. 切换到工作分支
2. 执行 git rebase
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>总而言之，上述两个规则总结起来就是一句话：</p><p><strong>时刻保证你当前的工作分支是『基于』最新的 master 远程分支</strong></p><h3 id="_7-2-工作流程" tabindex="-1"><a class="header-anchor" href="#_7-2-工作流程" aria-hidden="true">#</a> 7.2 工作流程</h3><p>这种工作流的整体流程如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>[1]. git clone 下载中央仓库的项目。

[2]. 创建属于自己的分支。如何创建见后续。

[3]. 等待项目经理安排任务。接受到项目经理安排的任务：实现某某功能，或修改某某 bug 。

while (true) {

    [4]. 是否满足核心准则一：本地 master 是否是最新的？
    if (不是) {
        a. 更新（本地）master 分支。 
    }

    [5]. 是否满足核心准则二：本地 xxx 是否是『基于』最新的 master ？
    if (不是) {
        a. 本地 xxx 分支变基。 
    }

    [6]. 判断是否完成了任务？
    if (是) {
        a. 更新（远程）xxx 分支。 
        b. 发起和并请求（pull request），并口头通知项目经理，希望他合并。
        c. break，跳出循环
    } 
    else if (否) {
        a. 写 5 分钟代码，努力完成项目经理安排的任务。 
    }
}

[7]. 回到上面第 [3] 步，再次等待项目经理安排新任务，开始新的工作周期。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>警告：不正常场景</p><p>1、场景一：本地 master 和中央仓库 master 不在一起，要解决很简单，对你的 master 分支执行 git pull 来更新你的本地仓库就行</p><p>2、场景二：本地开发分支不是基于最新的 master，出现这种情况和上一个场景有一定关系。本来你的开发分支是基于最新的 master ，但是由于中央仓库的 master 更新以后，你“当初的” 最新 master ，已经不再是 “最新” 了，对于这种情况，要解决也很简单，对你的开发分支执行 git rebase 变基就行了</p></blockquote><h2 id="_8-git私服" tabindex="-1"><a class="header-anchor" href="#_8-git私服" aria-hidden="true">#</a> 8.git私服</h2><p>参考gitea笔记部分</p>`,322),r=[t];function l(p,d){return e(),s("div",null,r)}const c=a(i,[["render",l],["__file","Gitgongzuoliu.html.vue"]]);export{c as default};
